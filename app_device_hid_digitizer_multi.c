/********************************************************************
 Software License Agreement:

 The software supplied herewith by Microchip Technology Incorporated
 (the "Company") for its PIC(R) Microcontroller is intended and
 supplied to you, the Company's customer, for use solely and
 exclusively on Microchip PIC Microcontroller products. The
 software is owned by the Company and/or its supplier, and is
 protected under applicable copyright laws. All rights are reserved.
 Any use in violation of the foregoing restrictions may subject the
 user to criminal sanctions under applicable laws, as well as to
 civil liability for the breach of the terms and conditions of this
 license.

 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *******************************************************************/


/********************************************************************
To use this demo, program a device with the firmware from this project.
Then plug the device into a Windows 7 or Windows Vista SP1+ based PC.

MSDN documentation for the "WM_GESTURE" messages indicate that they are
currently only supported in Windows 7.  WM_GESTURE messages can be used
by PC applications to receive information related to a user's input.  
However, Windows Vista SP1 still has some digitizer input 
capabilities, and can therefore still be used to experiment with this demo.
The demo experience will be superior under Windows 7 however, as not
all touch related capabilities and features are enabled in Windows Vista.

The device should enumerate as a HID class multi-touch capable
digitizer device.  Windows 7 and Windows Vista features associated 
with "Windows Touch" should automatically become activated.  
Under default versions of Windows XP, the device should still enumerate 
as a HID class device, but no new digitizer input functionality will 
be activated.

Digitizer tablets send absolute contact position information
to the host.  This is a bit different compared to conventional mouse
devices, in that mice send relative X/Y direction movement information,
instead of an absolute location.

Since the demo boards that this firmware is intended to be run on
do not include an actual multi-touch tablet area, the firmware simply
emulates the tablet by sending the same data (and formatting) that a tablet
would actually be used to produce.  The demo board pushbutton "sw3"
(see definition in the HardwareProfile - (board name).h file)
can be used to make the demo board send simulated gesture info to the host.

To use this demo, open up an Internet Explorer window, and go to some website 
(ex: www.microchip.com/usb).
The web page opened should be large enough that both vertical and 
horizontal scrollbars will become active when zoomed in. Click on some 
link, and then click the back button.  The purpose of this is to enable both 
the forward and back buttons in the web broswer.  
This demo will send gesture information to the OS that can be interpreted as 
forward and back "flick" gestures, which can be used to control the web browser.

Now try pressing the pushbutton on the demo board repeatedly.  Each press
of the pushbutton should send a bunch of IN packets to the host, which contain
the information that would typically be generated by a human user interacting 
with a multi-touch capable digitizer screen.

The firmware will send traffic to emulate both single touch and multi-touch 
(up to 2 simultaneous contacts) gestures, based on the number of times the
pushbutton has been pressed.  Under Windows 7 (Vista will be somewhat different),
the following gestures will be sent and should be recognized by Internet Explorer:

1.  Emulate a single touch "back" gesture operation.  
		This is done by pressing only one finger down, and by moving it right quickly (X plus)
2.  Emulate a single touch "forward" gesture operation.  
		This is done by pressing only one finger down, and by moving it left quickly (X minus)
3.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
4.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
5.  Emulate a multi-touch zoom-in operation ("un-pinch" index and thumb fingers)
6.  Emulate a multi-touch horizontal scroll right operation 
      This is done by using two fingers simultaneously and moving them both to the left (X minus)
7.  Emulate a multi-touch horizontal scroll left operation
      This is done by using two fingers simultaneously and moving them both to the right (X plus)
8.  Emulate a single touch scroll down operation.  
      This is done by pressing only one finger down, and by moving it down (Y plus)
9.  Emulate a single touch scroll up operation.  
      This is done by pressing only one finger down, and by moving it up (Y minus)
10. Emulate a multi-touch zoom-out operation (pinch two fingers together)

11+. Upon pressing the button 11 times, the firmware will go back to state 1. Subsequent 
       presses of the button will step through and repeat the above gestures 1-10.

Note: The above demo zooms in three times in a row (presses 3-5).  The purpose of this
is to zoom in sufficiently so that the horizontal and vertical scoll bars will become
active.  The gestures associated with button presses 6-9 perform scroll operations,
but only if the scroll bars are active.

Note2: This demo was tested and developed primarily on 64-bit Windows 7 beta build 7000, 
with some additional testing on Windows Vista SP1.  At the time of this development,
Windows 7 is not yet a finalized and released product.  If you have trouble getting
this demo to work correctly, check to see if there is a later version of this demo
available from the Microchip USB design center: www.microchip.com/usb

Additionally, try adjusting some of the user adjustable controls for 
Pen and Touch Input Devices.  These adjustments can be found from the control panel 
within Windows.


This demo is configured by default to support up to two simultaneous contacts,
by using "parallel reporting" (all data for each contact is contained in each
HID report packet sent to the host).  The demo can be modified to support additional
contacts if the report descriptor in usb_config.h is modified, and the appropriate
contact data is sent to the host for each HID report.
********************************************************************/


/** INCLUDES *******************************************************/
#include <stdint.h>
#include <stdbool.h>

#include <system.h>

#include <usb/usb.h>
#include <usb/usb_device_hid.h>

#include "touchpanel.h"

/** VARIABLES ******************************************************/
/* Some processors have a limited range of RAM addresses where the USB module
 * is able to access.  The following section is for those devices.  This section
 * assigns the buffers that need to be used by the USB module into those
 * specific areas.
 */
#if defined(FIXED_ADDRESS_MEMORY)
    #if defined(COMPILER_MPLAB_C18)
        #pragma udata DEVICE_HID_DIGITIZER_IN_BUFFER=DEVICE_HID_DIGITIZER_IN_BUFFER_ADDRESS
            static unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
        #pragma udata DEVICE_HID_DIGITIZER_OUT_BUFFER=DEVICE_HID_DIGITIZER_OUT_BUFFER_ADDRESS
            static unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
        #pragma udata
    #elif defined(__XC8)
        static unsigned char hid_report_in[HID_INT_IN_EP_SIZE] DEVICE_HID_DIGITIZER_IN_BUFFER_ADDRESS;
        static unsigned char hid_report_out[HID_INT_OUT_EP_SIZE] DEVICE_HID_DIGITIZER_OUT_BUFFER_ADDRESS;
    #endif
#else
    static unsigned char hid_report_in[HID_INT_IN_EP_SIZE];
    static unsigned char hid_report_out[HID_INT_OUT_EP_SIZE];
#endif
USB_HANDLE lastTransmission;

static bool HIDApplicationModeChanging;
static uint8_t DeviceIdentifier;

/** DEFINITIONS ****************************************************/
//DeviceMode variable values.  See also the usb_config.h "DEFAULT_DEVICE_MODE" definition.
#define MULTI_TOUCH_DIGITIZER_MODE      0x02

/** Private Prototypes *********************************************/
static void USBHIDCBSetReportComplete(void);

/*********************************************************************
* Function: void APP_DeviceHIDDigitizerInitialize(void);
*
* Overview: Initializes the demo code
*
* PreCondition: None
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerInitialize()
{
    //enable the HID endpoint
    USBEnableEndpoint(HID_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);

    //initialize the variable holding the handle for the last
    // transmission
    lastTransmission = 0;

    HIDApplicationModeChanging = false;

    //Initialize device mode and digitizer emulation variables.
    //--------------------------------------------------------
    DeviceIdentifier = 0x01;
}

/*********************************************************************
* Function: void APP_DeviceHIDDigitizerInitialize(void);
*
* Overview: Initializes the demo code
*
* PreCondition: None
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerSOFHandler()
{
    // No need to clear UIRbits.SOFIF to 0 here.
    // Callback caller is already doing that.

    //Using SOF packets (which arrive at 1ms intervals) for time
    //keeping purposes in this demo.  This enables this demo to send constant
    //velocity contact point X/Y coordinate movement.
    //SOFCount++;
}


/*********************************************************************
* Function: void APP_DeviceHIDDigitizerTasks(void);
*
* Overview: Keeps the Custom HID demo running.
*
* PreCondition: The demo should have been initialized and started via
*   the APP_DeviceHIDDigitizerInitialize() and APP_DeviceHIDDigitizerStart() demos
*   respectively.
*
* Input: None
*
* Output: None
*
********************************************************************/
void APP_DeviceHIDDigitizerTasks()
{
    /* If the device is not configured yet, or if the device is suspended
     * then exit this function immediately since we can't actually send any
     * application data.
     */
    if( (USBGetDeviceState() < CONFIGURED_STATE) || 
        (USBIsDeviceSuspended() == true) )
    {
        return;
    }

    //Don't want to send any report packets on EP1 IN to the host when
    //the host is in the process of sending a control transfer (ex: SET_REPORT)
    //and is changing the device mode.  Need to wait until the control transfer
    //is complete and the new device mode setting has taken effect.
    if(HIDApplicationModeChanging == true)
    {
        return;
    }

}


/********************************************************************
 * Function:        void UserGetReportHandler(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        UserGetReportHandler() is used to respond to
 *                      the HID device class specific GET_REPORT control
 *                      transfer request (starts with SETUP packet on EP0 OUT).
 *                  This get report handler callback function is placed
 *                      here instead of in usb_function_hid.c, since this code
 *                      is "custom" and needs to be specific to this particular
 *                      application example.  For this HID digitizer device,
 *                      we need to be able to correctly respond to
 *                      GET_REPORT(feature) requests.  The proper response to this
 *                      type of request depends on the HID report descriptor (in
 *                      usb_descriptors.c).
 * Note:
 *******************************************************************/
void UserGetReportHandler(void)
{
    uint8_t bytesToSend;

    //Check if request was for a feature report with report ID = VALID_CONTACTS_FEATURE_REPORT_ID = 0x02.
    //wValue MSB = 0x03 is Feature report (see HID1_11.pdf specifications),
    //LSB = VALID_CONTACTS_FEATURE_REPORT_ID is Report ID "0x02".  This feature report ID
    //is used for reporting the maximum number of supported simultaneous contacts (in multi-touch mode).
    if(SetupPkt.wValue == (0x0300 + VALID_CONTACTS_FEATURE_REPORT_ID))
    {
        static uint8_t FeatureReport[2];

        //Prepare a response packet for the host
        FeatureReport[0] = VALID_CONTACTS_FEATURE_REPORT_ID;
        FeatureReport[1] = MAX_VALID_CONTACT_POINTS;	//Three contacts valid for this multi-touch demo (can be increased by increasing this number and editing report descriptor and report data payload)

        //Determine number of bytes to send to the host
        if(SetupPkt.wLength < 2u)
        {
            bytesToSend = SetupPkt.wLength;
        }
        else
        {
            //Size of the feature report.  Byte 0 is Report ID = 0x02, Byte 1 is
            //the maximum contacts value, which is "2" for this demo
            bytesToSend = 2;
        }

        //Now send the reponse packet data to the host, via the control transfer on EP0
        USBEP0SendRAMPtr((uint8_t*)&FeatureReport, bytesToSend, USB_EP0_RAM);
    }
}

/********************************************************************
 * Function:        void UserSetReportHandler(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:    UserSetReportHandler() is used to respond to
 *              the HID device class specific SET_REPORT control
 *              transfer request (starts with SETUP packet on EP0 OUT).
 *
 *              This get report handler callback function is placed
 *              here instead of in usb_function_hid.c, since this code
 *              is "custom" and needs to be specific to this particular
 *              application example.  For this HID digitizer device, which
 *              supports multiple device modes, we need to be able to
 *              correctly respond to SET_FEATURE requests.  The proper response
 *              to this type of request depends on the HID report descriptor (in
 *              usb_descriptors.c).
 * Note:
 *******************************************************************/
void UserSetReportHandler(void)
{
    if(SetupPkt.wValue == (0x0300 + DEVICE_MODE_FEATURE_REPORT_ID))	//Host is setting the device mode (ex: mouse, single-touch digitizer, multi-touch digitizer)
    {
        //Temporarily stop sending HID report data packets on EP1 IN until
        //the new mode has been fully set/takes effect.
        HIDApplicationModeChanging = true;

        //If firmware gets to here, the host PC is trying to change the device mode.
        //If the EP1 IN endpoint was already armed and filled with report data (from
        //the previous mode setting, ex: a mouse report), then the first packet
        //sent to the host after the SET_REPORT control transfer completes might
        //contain the wrong data/be for the wrong mode.  To ensure that all packets
        //are consistent to the currently configured mode, even during switchover
        //events, special handling should be done to dis-arm EP1 IN until the new
        //mode setting is complete.

        //Check if the EP1 IN endpoint was already armed.  If so, need to abandon the
        //operation to avoid sending any packets, until the new mode has been set.
        if(USBHandleBusy(lastTransmission))	//effectively: if(EP1 IN UOWN bit == 1)
        {
            //In this case we need to terminate the pending USB transfers on the
            //  HID endpoint.
            USBCancelIO(HID_EP);
        }

        //Prepare EP0 to receive the control transfer data (the device mode to set)
        USBEP0Receive((uint8_t*)&hid_report_out, SetupPkt.wLength, USBHIDCBSetReportComplete);	//Host will send two bytes.  After the two bytes are successfully received, call the USBHIDCBSetReportComplete() callback function.
    }
}


//Secondary callback function that gets called when the above
//control transfer,  USBEP0Receive(...,...,USBHIDCBSetReportComplete) completes.
static void USBHIDCBSetReportComplete(void)
{
    //The hid_report_out[0] byte contains the Report ID that is getting set.
    //The hid_report_out[1] byte contains the Device Mode
    //The hid_report_out[2] byte contains the DeviceIdentifier

    //The new device mode setting has been set.  Okay to start sending HID report
    //packets again on EP1 IN now.
    HIDApplicationModeChanging = false;
}

